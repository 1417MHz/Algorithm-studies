- 알고리즘 공부법
1) 책의 문제를 푼 다음 온라인 저지 사이트에서 동일 유형의 문제를 풀어보자
2) 기초 알고리즘지식이 있다면 문제를 많이 풀고 복기해보자
3) 복기한 내용은 개인 블로그나 깃허브로 기록을 남기자.


- 복잡도
복잡도는 알고리즘의 성능을 나타내는 척도이다. 복잡도는 시간 복잡도와 공간 복잡도로 나뉜다.
시간 복잡도는 특정한 크기의 입력에 대하여 알고리즘이 얼마나 오래 걸리는지를 의미하고, 
 공간 복잡도는 특정한 크기의 입력에 대하여 알고리즘이 얼마나 많은 메모리를 차지하는지를 의미한다.

- 시간 복잡도
알고리즘 문제에서 단순히 '복잡도'라고 하면 보통 시간 복잡도를 의미한다. 시간 복잡도를 포현할 때는 Big-O 표현법을 사용한다.
예를들어 5개의 데이터를 받아 차례대로 5회 더해주는(N=5) 코드가 있다. 이때 연산 횟수는 N에 비례하므로 시간 복잡도는 O(N)이다.
또 다른 예로 리스트에 5개의 데이터가 있고, 2중 반복문을 이용하여 각 원소에 대하여 다른 모든 원소에 대한 곱셈 결과를 출력하는
 코드가 있다. 간단히 설명하면 N*N만큼의 연산이 필요하므로 시간 복잡도는 O(N^2)라고 할 수 있다.
다만 모든 2중반복문이 O(N^2)는 아니다.(반복문 속에 내부적으로 다른 함수를 호출한다면 복잡도가 달라진다)
Big-O 표기법은 각각의 명칭이 있다. O(1)은 상수 시간, O(logN)은 로그 시간, O(N)은 선형 시간, O(NlogN)은 로그 선형시간,
 O(N^2)는 이차 시간이라고 부른다. N이 1000일 경우의 연산 횟수는 O(N) = 1,000 , O(NlogN) = 10,000 , O(N^2) = 1,000,000 ,
 O(N^3) = 1,000,000,000회 이다. 여기서 일반적으로 복잡도가 O(N^3)을 초과할 경우 문제풀이에 사용하기 어렵다.
시간복잡도 분석은 문제 풀이의 핵심이다. 문제의 조건을 확인하고, 데이터의 크기나 탐색 범위를 확인하고 사용할 수 있는 알고리즘을
 파악해야 한다.
 시간제한이 1초인 문제의 경우:
 N = 500 - O(N^3)
 N = 2000 - O(N^2)
 N = 100,000 - O(NlogN)
 N = 10,000,000 - O(N)의 알고리즘을 설계할 수 있다.
 
 시간 복잡도에서의 '연산'은 프로그래밍 언어에서 지원하는 사칙 연산, 비교 연산 등과 같은 기본 연산을 의미한다.
 예를 들어 두 정수 a와 b를 더하는 더하기 연산뿐만 아니라, 두 정수 a와 b의 값을 비교하는 비교 연산 또한 한 번의 연산으로 취급한다.
 
 - 공간 복잡도
 코딩테스트에서는 보통 메모르 사용량을 128~512mb정도로 제한한다. 일반적인 경우 데이터의 개수가 1천만 단위가 넘어가지 않도록
 설계해야 한다. 파이썬에서도 대략 1백만개 이상의 데이터가 들어갈 수 있는 크기의 리스트를 선언하는 경우는 드물다.
 
 파이썬에서는 프로그램 수행 시간을 측정할 수 있다. 수행 시간을 확인해야 자신이 제대로 알고리즘을 작성하고 있는지 체크할 수 있다.
 //
 import time
 start_time = time.time() # 측정 시작
 # 프로그램 소스코드
 end_time = time.time() # 측정 종료
 print(end_time - start_time) # 수행 시간 출력
 //
 
 - 코딩 테스트 문제 유형 분석
 코딩 테스트는 문제 해결 능력을 확인하는 시험이다. 코딩 테스트에는 주로 기초 알고리즘에 기반하는 문제가 출제된다.
 그중에서 출제 빈도가 가장 높은 문제는 그리디, 구현, DFS/BFS를 이용한 탐색 문제이다. 또한 상대적으로 높은 사고력을 요구하는
 다이나믹 프로그래밍이나 그래프 이론 문제도 출제된다. 다만 이런 유형의 문제는 출제되더라도 난이도가 높지 않은 경향이 있다.
 
